'''
From https://github.com/erocarrera/pefile/blob/wiki/UsageExamples.md#reading-and-writing-standard-header-members
Starting from pefile 1.2 it's possible to write back any 
changes done to the PE file. One has to be careful with this 
functionality as it will not be very intelligent reconstructing 
the PE file. That is, it will not handle displacing structures 
if that would be needed because a new section/structure has been 
added. The rule of thumb is, if there's room for an additional 
header/structure to fit then there'll be no problem and pefile 
will write it. All other modifications, i.e. changing individual 
values in header/structure members should work well. One possible 
useful application of this could be to correct malformed headers 
used by some malware in order to cause certain analysis tools to 
malfunction.
'''

# TODO: self-sign via osslsigncode

import pefile
import random
import tempfile

defaults = {
    'min_append_log2': 5,
    'max_append_log2': 8,
}

import os
import sys
module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]
COMMON_SECTION_NAMES = open(os.path.join(
    module_path, 'section_names.txt'), 'r').read().rstrip().split('\n')

######################
''' Append random-length zero bytes.  Breaks signature if signed '''


def append_zero(bytez, n_to_append=None):
    if not n_to_append:
        n_to_append = 2**random.randint(
            defaults['min_append_log2'], defaults['max_append_log2'])
    return bytez + b'\0' * n_to_append


''' Append random-length ascii characters.  Breaks signature if signed '''


def append_random_ascii(bytez, n_to_append=None):
    if not n_to_append:
        n_to_append = 2**random.randint(
            defaults['min_append_log2'], defaults['max_append_log2'])
    for _ in range(n_to_append):
        random_ascii = bytes(random.randint(0, 127))
        bytez += random_ascii
    return bytez


''' Append random-length bytes.  Breaks signature if signed '''


def append_random_bytes(bytez, n_to_append=None):
    if not n_to_append:
        n_to_append = 2**random.randint(
            defaults['min_append_log2'], defaults['max_append_log2'])
    for _ in range(n_to_append):
        random_ascii = bytes(random.randint(0, 255))
        bytez += random_ascii
    return bytez


''' Remove a signature '''


def remove_signature(bytez):
    """Removes signature by overwriting that section with 0s."""
    # graciously borrowed from Didier Stevens' disitool
    # https://blog.didierstevens.com/programs/disitool/

    try:
        pe = pefile.PE(data=bytez)
    except (KeyboardInterrupt, SystemExit):
        raise
    except:
        return bytez

    try:
        address = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY[
            'IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress
    except IndexError:
        return bytez  # unmodified

    pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY[
        'IMAGE_DIRECTORY_ENTRY_SECURITY']].VirtualAddress = 0
    pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY[
        'IMAGE_DIRECTORY_ENTRY_SECURITY']].Size = 0

    if address != 0:
        pe_unsigned = pefile.PE(data=pe.write()[0:address])
    else:
        pe_unsigned = pefile.PE(data=pe.write())

    pe_unsigned.OPTIONAL_HEADER.CheckSum = pe_unsigned.generate_checksum()

    return pe_unsigned.write()


''' UPX unpack the file '''
import subprocess
import os


def upx_unpack(bytez):
    # dump bytez to a temporary file
    tmpfilename = os.path.join(
        tempfile._get_default_tempdir(), next(tempfile._get_candidate_names()))

    with open(tmpfilename, 'wb') as outfile:
        outfile.write(bytez)

    with open(os.devnull, 'w') as DEVNULL:
        retcode = subprocess.call(
            ['upx', tmpfilename, '-d', '-o', tmpfilename + '_unpacked'], stdout=DEVNULL, stderr=DEVNULL)

    os.unlink(tmpfilename)

    if retcode == 0:  # sucessfully unpacked
        with open(tmpfilename + '_unpacked', 'rb') as result:
            bytez = result.read()

        os.unlink(tmpfilename + '_unpacked')

    return bytez


''' UPX pack the file '''


def upx_pack(bytez):
    tmpfilename = os.path.join(
        tempfile._get_default_tempdir(), next(tempfile._get_candidate_names()))

    # dump bytez to a temporary file
    with open(tmpfilename, 'wb') as outfile:
        outfile.write(bytez)

    options = ['--force --exact --overlay=copy']
    compression_level = random.randint(1, 9)
    options += ['-{}'.format(compression_level)]
    # --exact
    # compression levels -1 to -9
    # --overlay=copy [default]

    # optional things:
    # --compress-exports=0/1
    # --compress-icons=0/1/2/3
    # --compress-resources=0/1
    # --strip-relocs=0/1
    options += ['--compress-exports={}'.format(random.randint(0, 1))]
    options += ['--compress-icons={}'.format(random.randint(0, 3))]
    options += ['--compress-resources={}'.format(random.randint(0, 1))]
    options += ['--strip-reclocs={}'.format(random.randint(0, 1))]

    with open(os.devnull, 'w') as DEVNULL:
        retcode = subprocess.call(['upx'] + options + [tmpfilename, '-o',
                                                       tmpfilename + '_packed'], stdout=DEVNULL, stderr=DEVNULL)

    os.unlink(tmpfilename)

    if retcode == 0:  # successfully packed

        with open(tmpfilename + '_packed', 'rb') as infile:
            bytez = infile.read()

        os.unlink(tmpfilename + '_packed')

    return bytez


''' change a random section name to one of several common names '''


def change_section_names_from_list(bytez):
    try:
        pe = pefile.PE(data=bytez)
    except (KeyboardInterrupt, SystemExit):
        raise
    except:
        return bytez

    if hasattr(pe, 'sections') and len(pe.sections) > 0:
        # pick a random section and rename it
        chosen_section = random.choice(pe.sections)
        newname = random.choice(COMMON_SECTION_NAMES)
        while len(newname) < 8:
            newname += b'\x00'
        chosen_section.Name = newname

        return pe.write()  # verified that this actually does change the file
    else:
        return bytez


''' change a random section name to a random alphanumeric string '''


def change_section_names_to_random(bytez):
    try:
        pe = pefile.PE(data=bytez)
    except (KeyboardInterrupt, SystemExit):
        raise
    except:
        return bytez

    if hasattr(pe, 'sections') and len(pe.sections) > 0:
        chosen_section = random.choice(pe.sections)

        random_name = ''.join(random.choice(
            '0123456789ABCDEFGHJKLMNOPQRSTUVWXYZ.!?abcdefghijklmnopqrstuvwxyz') for i in range(8))
        chosen_section.Name = random_name

        return pe.write()  # verified that this actually does change the file
    else:
        return bytez


''' remove reference of any debug section from the data directory '''


def remove_debug(bytez):
    try:
        pe = pefile.PE(data=bytez)
        pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_DEBUG']].Size = 0
        pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_DEBUG']].VirtualAddress = 0
        pe.OPTIONAL_HEADER.CheckSum = pe.generate_checksum()
    except (KeyboardInterrupt, SystemExit):
        raise
    except:
        return bytez

    return pe.write()


def break_optional_header_checksum(bytez):
    try:
        pe = pefile.PE(data=bytez)
        pe.OPTIONAL_HEADER.CheckSum = 0
    except (KeyboardInterrupt, SystemExit):
        raise
    except:
        return bytez

    return pe.write()


''' change the names of an exported symbol '''


def modify_exports(bytez):
    try:
        pe = pefile.PE(data=bytez)
    except (KeyboardInterrupt, SystemExit):
        raise
    except:
        return bytez
    if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT') and len(pe.DIRECTORY_ENTRY_EXPORT.symbols) > 0 and any(pe.DIRECTORY_ENTRY_EXPORT.symbols):
        choose_from = [
            s for s in pe.DIRECTORY_ENTRY_EXPORT.symbols if s.name is not None]
        if not choose_from:
            return bytez

        chosen_export = random.choice(choose_from)

        name_len = len(chosen_export.name)
        random_name = ''.join(random.choice(
            '0123456789ABCDEFGHJKLMNOPQRSTUVWXYZ.!?abcdefghijklmnopqrstuvwxyz') for i in range(name_len))

        chosen_export.name = random_name

        return pe.write()
    else:
        return bytez

# # TO DO: this one may currently overwrite section data, because pefile isn't bookkeeping well
# ''' append a new imported dll and functions that will never be used '''
# def add_random_import( bytez ):
#   pe = pefile.PE( data=bytez )
#   if len( pe.DIRECTORY_ENTRY_IMPORTS ) > 0:

#       chosen_export = random.choice( pe.DIRECTORY_ENTRY_EXPORT.symbols )

#       name_len = len(chosen_export.name)
#       random_name = ''.join(random.choice('0123456789ABCDEFGHJKLMNOPQRSTUVWXYZ.!?abcdefghijklmnopqrstuvwxyz') for i in range(name_len))

#       chosen_export.name = random_name

#       return pe.write()
#   else:
#       return bytez


def identity(bytez):
    return bytez


######################
# explicitly list so that these may be used externally
ACTION_TABLE = {
    'do_nothing': identity,
    'append_zero': append_zero,
    'append_random_ascii': append_random_ascii,
    'append_random_bytes': append_random_bytes,
    'remove_signature': remove_signature,
    'upx_pack': upx_pack,
    'upx_unpack': upx_unpack,
    'change_section_names_from_list': change_section_names_from_list,
    'change_section_names_to_random': change_section_names_to_random,
    'modify_exports': modify_exports,
    'remove_debug': remove_debug,
    'break_optional_header_checksum': break_optional_header_checksum,
}


def modify_without_breaking(bytez, actions=[]):
    for action in actions:
        try:
            bytez = ACTION_TABLE[action](bytez)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            pass
    return bytez
